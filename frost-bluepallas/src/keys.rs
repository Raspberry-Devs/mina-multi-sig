use std::collections::BTreeMap;

use frost_core::{self as frost, Ciphersuite, Group};
use rand_core::{CryptoRng, RngCore};

use crate::{Error, Identifier, PallasPoseidon, VerifyingKey, P};

pub mod dkg;

pub type IdentifierList<'a> = frost::keys::IdentifierList<'a, P>;

/// Secret and public key material generated by a dealer performing
/// [`generate_with_dealer`].
///
/// # Security
///
/// To derive a FROST(Pallas, Poseidon) keypair, the receiver of the [`SecretShare`] *must* call
/// .into(), which under the hood also performs validation.
pub type SecretShare = frost::keys::SecretShare<P>;

/// A secret scalar value representing a signer's share of the group secret.
pub type SigningShare = frost::keys::SigningShare<P>;

/// A public group element that represents a single signer's public verification share.
pub type VerifyingShare = frost::keys::VerifyingShare<P>;

/// A FROST(Pallas, Posiedon) keypair, which can be generated either by a trusted dealer or using
/// a DKG.
///
/// When using a central dealer, [`SecretShare`]s are distributed to
/// participants, who then perform verification, before deriving
/// [`KeyPackage`]s, which they store to later use during signing.
pub type KeyPackage = frost::keys::KeyPackage<P>;

/// Public data that contains all the signers' public keys as well as the
/// group public key.
///
/// Used for verification purposes before publishing a signature.
pub type PublicKeyPackage = frost::keys::PublicKeyPackage<P>;

/// Contains the commitments to the coefficients for our secret polynomial _f_,
/// used to generate participants' key shares.
///
/// [`VerifiableSecretSharingCommitment`] contains a set of commitments to the coefficients (which
/// themselves are scalars) for a secret polynomial f, where f is used to
/// generate each ith participant's key share f(i). Participants use this set of
/// commitments to perform verifiable secret sharing.
///
/// Note that participants MUST be assured that they have the *same*
/// [`VerifiableSecretSharingCommitment`], either by performing pairwise comparison, or by using
/// some agreed-upon public location for publication, where each participant can
/// ensure that they received the correct (and same) value.
pub type VerifiableSecretSharingCommitment = frost::keys::VerifiableSecretSharingCommitment<P>;

pub fn generate_with_dealer<RNG: RngCore + CryptoRng>(
    max_signers: u16,
    min_signers: u16,
    identifiers: IdentifierList,
    mut rng: RNG,
) -> Result<(BTreeMap<Identifier, SecretShare>, PublicKeyPackage), Error> {
    frost::keys::generate_with_dealer(max_signers, min_signers, identifiers, &mut rng)
        .map(into_even_y)
}

/// Copied from https://github.com/ZcashFoundation/reddsa/blob/main/src/frost/redpallas.rs
pub trait EvenY {
    /// Return if the given type has a group public key with an even Y
    /// coordinate.
    fn has_even_y(&self) -> bool;

    /// Convert the given type to make sure the group public key has an even
    /// Y coordinate. `is_even` can be specified if evenness was already
    /// determined beforehand. Returns a boolean indicating if the original
    /// type had an even Y, and a (possibly converted) value with even Y.
    fn into_even_y(self, is_even: Option<bool>) -> Self;
}

impl EvenY for PublicKeyPackage {
    fn has_even_y(&self) -> bool {
        let verifying_key = self.verifying_key();
        match verifying_key.serialize() {
            Ok(verifying_key_serialized) => verifying_key_serialized[31] & 0x80 == 0,
            // If serialization fails then it's the identity point, which has even Y
            Err(_) => true,
        }
    }

    fn into_even_y(self, is_even: Option<bool>) -> Self {
        let is_even = is_even.unwrap_or_else(|| self.has_even_y());
        if !is_even {
            // Negate verifying key
            let verifying_key = VerifyingKey::new(-self.verifying_key().to_element());
            // Recreate verifying share map with negated VerifyingShares
            // values.
            let verifying_shares: BTreeMap<_, _> = self
                .verifying_shares()
                .iter()
                .map(|(i, vs)| {
                    let vs = VerifyingShare::new(-vs.to_element());
                    (*i, vs)
                })
                .collect();
            PublicKeyPackage::new(verifying_shares, verifying_key)
        } else {
            self
        }
    }
}

impl EvenY for SecretShare {
    fn has_even_y(&self) -> bool {
        let key_package: KeyPackage = self
            .clone()
            .try_into()
            .expect("Should work; expected to be called in freshly generated SecretShares");
        key_package.has_even_y()
    }

    fn into_even_y(self, is_even: Option<bool>) -> Self {
        let is_even = is_even.unwrap_or_else(|| self.has_even_y());
        if !is_even {
            // Negate SigningShare
            let signing_share = SigningShare::new(-self.signing_share().to_scalar());
            // Negate VerifiableSecretSharingCommitment by negating each
            // coefficient in it. TODO: remove serialization roundtrip
            // workaround after required functions are added to frost-core
            let coefficients: Vec<_> = self
                .commitment()
                .coefficients()
                .iter()
                .map(|e| {
                    <PallasPoseidon as Ciphersuite>::Group::serialize(&-e.value())
                        .expect("none of the coefficient commitments are the identity")
                })
                .collect();
            let commitments = VerifiableSecretSharingCommitment::deserialize(coefficients)
                .expect("Should work since they were just serialized");
            SecretShare::new(*self.identifier(), signing_share, commitments)
        } else {
            self
        }
    }
}

impl EvenY for KeyPackage {
    fn has_even_y(&self) -> bool {
        let pubkey = self.verifying_key();
        match pubkey.serialize() {
            Ok(pubkey_serialized) => pubkey_serialized[31] & 0x80 == 0,
            // If serialization fails then it's the identity point, which has even Y
            Err(_) => true,
        }
    }

    fn into_even_y(self, is_even: Option<bool>) -> Self {
        let is_even = is_even.unwrap_or_else(|| self.has_even_y());
        if !is_even {
            // Negate all components
            let verifying_key = VerifyingKey::new(-self.verifying_key().to_element());
            let signing_share = SigningShare::new(-self.signing_share().to_scalar());
            let verifying_share = VerifyingShare::new(-self.verifying_share().to_element());
            KeyPackage::new(
                *self.identifier(),
                signing_share,
                verifying_share,
                verifying_key,
                *self.min_signers(),
            )
        } else {
            self
        }
    }
}

pub(crate) fn into_even_y(
    (secret_shares, public_key_package): (BTreeMap<Identifier, SecretShare>, PublicKeyPackage),
) -> (BTreeMap<Identifier, SecretShare>, PublicKeyPackage) {
    let is_even = public_key_package.has_even_y();
    let public_key_package = public_key_package.into_even_y(Some(is_even));
    let secret_shares = secret_shares
        .iter()
        .map(|(i, s)| (*i, s.clone().into_even_y(Some(is_even))))
        .collect();
    (secret_shares, public_key_package)
}
